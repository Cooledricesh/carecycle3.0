{
  "rules": [
    {
      "type": "prd",
      "content": "# 환자 반복 검사·주사 일정 자동화 MVP – PRD\n\n## 1. 제품 개요\n중형 병원 간호사가 반복되는 검사·주사 일정을 **손쉽게 등록·추적·체크**할 수 있도록 돕는 **초간단 웹 기반 일정 관리·자동 체크리스트** 툴. 수작업 일정 누락·오류를 제거하고 업무 시간을 절감하는 것이 핵심 목표.\n\n## 2. 핵심 사용자\n- **주 사용자:** 중형 병원 간호사(30~300병상 규모)\n- 보조 사용자: 간호과장/수간호사(관리·감독), 행정직원(초기 환자 등록)\n\n## 3. 문제 정의(Pain Points)\n1. 스프레드시트 또는 수기 기록으로 인한 **일정 누락·오류**\n2. **반복적 계산**(다음 예정일)을 사람 손으로 처리 → 시간 소모·실수\n3. 오늘 해야 할 환자·항목을 **한눈에 보기 어려움**\n4. 일정 알림 부재 → 지연 발생, 환자 안전 리스크\n\n## 4. 사용자 목표\n1. **검사·주사 일정 누락 0%** 달성\n2. 매일 체크리스트 처리 시간을 **50% 이상 단축**\n\n## 5. 주요 기능(Scope)\n| 분류 | 기능 | 상세 | 우선순위 |\n|---|---|---|---|\n| 일정 자동 생성/관리 | 환자 등록 | 이름, 환자번호, 담당 항목 선택 | Must |\n| | 반복 주기 설정 | 항목별 일/주/월/주기값 입력 | Must |\n| | 최초 시행일 입력 시 다음 예정일 자동 계산 | Must |\n| | 실제 시행일 수정 시 다음 예정일 재계산 | Must |\n| 일일 체크리스트 | 오늘 예정 환자 자동 리스트업 | Must |\n| | 시행 여부 체크박스(2클릭 이내) | Must |\n| | 시행일 선택(기본 = 오늘) | Must |\n| 알림 | 예정일 1주 전 대시보드 표시 | Must |\n| | 예정일 Push 알림(브라우저) | Must |\n| 대시보드 | 항목별 진행 현황 요약(완료/미완료) | Must |\n| | 금일 시행 환자 목록 | Must |\n| 사용자 정의 항목 | 항목명·주기만 입력하여 즉시 추가 | Must |\n| 임포트 | CSV/Excel 환자 데이터 업로드(초기세팅) | Nice-to-have |\n| 로그 | 일정 변경 이력 보기 | Nice-to-have |\n\n## 6. 비기능 요구사항\n- **UX:** 2–3클릭 내 업무 완료, 테이블·체크박스 중심 심플 UI\n- **성능:** 1000명 환자, 10개 항목 기준 리스트 로드 < 1초\n- **보안:** 환자정보 암호화 저장, HTTPS 통신, 권한별 접근\n- **접근성:** 데스크톱 우선, 태블릿 대응(반응형)\n\n## 7. 가정 및 범위 외 항목\n- **EMR 연동 X** (CSV 내보내기/가져오기만 지원)\n- 환자 개인정보 최소치(이름, 환자번호)만 저장\n- 모바일 네이티브 앱, AI 추천 기능은 추후 로드맵\n\n## 8. KPI\n1. 누락된 일정 건수/월 → 0건 목표\n2. 간호사 체크리스트 작성 소요시간 → 50% 감소\n3. 일일 활성 사용자(DAU) / 등록 환자수 ≥ 80%\n\n## 9. 출시 로드맵\n| 단계 | 기간 | 범위 |\n|---|---|---|\n| 계획 & 디자인 | 1주 | 요구사항 확정, 와이어프레임 |\n| 개발 Sprint 1 | 2주 | 기본 환자/항목 CRUD, 자동 일정 생성 로직 |\n| 개발 Sprint 2 | 2주 | 일일 체크리스트 UI, 시행 체크, 알림 |\n| 개발 Sprint 3 | 1주 | 대시보드, CSV 업로드, QA |\n| Pilot 운영 | 2주 | 중형 병원 1곳, 피드백 수집 |\n| 개선 & 출시 | 1주 | 필수 개선, 문서화, 정식 배포 |\n\n## 10. 성공 기준\n- Pilot 병원 간호사 NPS ≥ 8\n- 일정 누락 0건 2주 연속 달성\n- 체크리스트 처리 시간 50% 단축 입증",
      "writedAt": "2025-08-16T08:11:56.248Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 문서 (TRD)\n\n## 1. 기술 요약\n- **프로젝트 개요**: 중형 병원 간호사를 위한 반복 검사/주사 일정 자동화 MVP 웹 애플리케이션 개발. Next.js 기반 프론트엔드와 Supabase를 활용한 백엔드 구성으로 빠른 개발 및 배포를 목표로 함. 사용자 경험을 최적화하기 위해 간단하고 직관적인 UI를 제공하며, 필수 기능 위주로 구현하여 빠른 MVP 출시를 지원함.\n- **핵심 기술 스택**: Next.js 15, TypeScript, TailwindCSS, shadcn, lucide-react, Supabase(PostgreSQL + Auth), @tanstack/react-query, es-toolkit, date-fns, Web Push API\n- **주요 기술 목표**:\n    - 빠른 응답 속도 및 부드러운 사용자 경험 제공\n    - 안정적인 데이터 관리 및 보안 유지\n    - 확장 가능한 아키텍처 설계\n- **주요 기술 가정**:\n    - 사용자 환경은 최신 데스크톱 브라우저를 사용한다고 가정\n    - Supabase의 안정적인 서비스 제공을 가정\n    - 네트워크 연결 상태가 양호하다고 가정\n\n## 2. 기술 스택\n\n| 범주              | 기술 / 라이브러리             | 사유                                                                                                                                                                                                                                                                                                                                                                                                         |\n| ----------------- | ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| 프레임워크        | Next.js 15                   | 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG)을 지원하여 초기 로딩 속도 향상. 라우팅, API 처리 등 다양한 기능을 내장하고 있어 개발 생산성 향상.                                                                                                                                                                                                                                                   |\n| 언어              | TypeScript                   | 정적 타입 지원으로 코드 안정성 및 유지보수성 향상. 개발 단계에서 오류를 사전에 발견하여 런타임 오류 감소.                                                                                                                                                                                                                                                                                             |\n| UI 프레임워크     | TailwindCSS                  | 유틸리티 우선 CSS 프레임워크로 빠른 UI 개발 가능. 컴포넌트 재사용성 및 일관성 유지.                                                                                                                                                                                                                                                                                                                               |\n| UI 컴포넌트       | shadcn                       | 재사용 가능한 UI 컴포넌트 제공. 디자인 시스템 일관성 유지 및 개발 속도 향상.                                                                                                                                                                                                                                                                                                                                        |\n| 아이콘            | lucide-react                 | 고품질의 벡터 아이콘 제공. UI 디자인 일관성 유지.                                                                                                                                                                                                                                                                                                                                                                 |\n| 백엔드            | Supabase(PostgreSQL + Auth) | BaaS(Backend as a Service) 형태로 데이터베이스, 인증, 스토리지 등 백엔드 기능을 제공하여 서버 관리 부담 감소. PostgreSQL 기반으로 안정적인 데이터 관리 가능.                                                                                                                                                                                                                                                 |\n| 상태 관리         | @tanstack/react-query        | 서버 상태 관리 라이브러리로 API 데이터 캐싱, 업데이트, 동기화 등 기능을 제공. 사용자 경험 향상 및 네트워크 요청 감소.                                                                                                                                                                                                                                                                                          |\n| 유틸리티          | es-toolkit                   | 유용한 유틸리티 함수 제공 (예: 문자열 조작, 배열 처리 등). 코드 재사용성 및 개발 생산성 향상.                                                                                                                                                                                                                                                                                                                      |\n| 날짜 처리         | date-fns                     | 날짜 및 시간 관련 기능 제공. 다양한 포맷 지원 및 시간대 처리.                                                                                                                                                                                                                                                                                                                                                        |\n| 푸시 알림         | Web Push API                 | 브라우저 푸시 알림 기능 제공. 사용자에게 실시간 알림 제공.                                                                                                                                                                                                                                                                                                                                                          |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 구성 요소\n- **프론트엔드 (Next.js)**: 사용자 인터페이스 및 사용자 상호 작용 처리.\n    - UI 컴포넌트 (shadcn, lucide-react)\n    - 상태 관리 (@tanstack/react-query)\n    - 라우팅 (Next.js 내장)\n- **백엔드 (Supabase)**: 데이터 저장, 인증, API 제공.\n    - 데이터베이스 (PostgreSQL)\n    - 인증 (Supabase Auth)\n    - API (Supabase Functions)\n- **푸시 알림 (Web Push API)**: 사용자에게 알림 전송.\n    - 푸시 서버 (Supabase Functions 또는 외부 서비스)\n    - 브라우저 푸시 서비스\n\n### 최상위 구성 요소 상호 작용 다이어그램\n\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] --> B[Backend (Supabase)]\n    B --> C[Database (PostgreSQL)]\n    A --> D[Web Push API]\n```\n\n- **프론트엔드 (Next.js) -> 백엔드 (Supabase)**: 사용자의 요청 (예: 환자 등록, 일정 확인)을 API를 통해 Supabase로 전송합니다.\n- **백엔드 (Supabase) -> 데이터베이스 (PostgreSQL)**: Supabase는 사용자의 요청에 따라 PostgreSQL 데이터베이스에서 데이터를 읽거나 씁니다.\n- **프론트엔드 (Next.js) -> Web Push API**: 사용자에게 푸시 알림을 보내기 위해 Web Push API를 사용합니다. 프론트엔드는 사용자 브라우저에 푸시 구독을 요청하고, 구독 정보를 백엔드로 전송합니다.\n- **백엔드 (Supabase) -> Web Push API**: 특정 이벤트 (예: 예정된 검사/주사 일정) 발생 시, 백엔드는 저장된 구독 정보를 사용하여 Web Push API를 통해 사용자에게 알림을 전송합니다.\n\n### 코드 구성 & 컨벤션\n**도메인 기반 구성 전략**\n- **도메인 분리**: 사용자 관리, 일정 관리, 알림 등 비즈니스 도메인별로 코드 분리.\n- **계층 기반 아키텍처**: 프레젠테이션 계층 (UI 컴포넌트), 비즈니스 로직 계층 (서비스), 데이터 접근 계층 (데이터베이스 쿼리)으로 분리.\n- **기능 기반 모듈**: 환자 등록, 일정 생성, 체크리스트 관리 등 기능별로 모듈화.\n- **공유 컴포넌트**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트는 shared 모듈에 저장.\n\n**유니버설 파일 & 폴더 구조**\n```\n/\n├── components/           # 재사용 가능한 UI 컴포넌트\n│   ├── PatientCard.tsx\n│   ├── Checkbox.tsx\n│   └── ...\n├── pages/                # Next.js 페이지 및 API 엔드포인트\n│   ├── index.tsx         # 메인 대시보드\n│   ├── patients/         # 환자 관련 페이지\n│   │   ├── [id].tsx    # 특정 환자 상세 정보\n│   │   └── new.tsx     # 신규 환자 등록\n│   └── api/              # API 엔드포인트\n│       ├── patients.ts   # 환자 관련 API\n│       └── ...\n├── services/             # 비즈니스 로직\n│   ├── patientService.ts # 환자 관련 서비스\n│   ├── scheduleService.ts # 일정 관련 서비스\n│   └── ...\n├── utils/                # 유틸리티 함수\n│   ├── dateUtils.ts      # 날짜 관련 유틸리티\n│   ├── api.ts            # API 클라이언트\n│   └── ...\n├── types/                # 타입 정의\n│   ├── patient.ts        # 환자 타입\n│   ├── schedule.ts       # 일정 타입\n│   └── ...\n└── ...\n```\n\n### 데이터 흐름 & 통신 패턴\n- **클라이언트-서버 통신**: API 요청/응답 패턴 (RESTful API).\n- **데이터베이스 상호 작용**: Supabase 클라이언트 라이브러리를 사용하여 데이터베이스 쿼리.\n- **외부 서비스 통합**: Web Push API를 사용하여 푸시 알림 전송.\n- **실시간 통신**: 실시간 기능은 필요하지 않음.\n- **데이터 동기화**: @tanstack/react-query를 사용하여 서버 상태와 클라이언트 상태 동기화.\n\n## 4. 성능 & 최적화 전략\n- **코드 분할 (Code Splitting)**: Next.js의 코드 분할 기능을 활용하여 초기 로딩 속도 최소화.\n- **이미지 최적화**: 이미지 크기 최적화 및 Lazy Loading 적용.\n- **API 응답 캐싱**: @tanstack/react-query를 사용하여 API 응답 캐싱.\n- **데이터베이스 쿼리 최적화**: 필요한 데이터만 조회하도록 쿼리 최적화. 인덱싱 활용.\n\n## 5. 구현 로드맵 & 마일스톤\n### 1단계: 기반 (MVP 구현)\n- **핵심 인프라**: Next.js 프로젝트 설정, Supabase 연동, 기본 UI 구성.\n- **필수 기능**: 환자 등록, 항목 등록, 반복 주기 설정, 다음 예정일 자동 계산, 오늘 예정 환자 자동 리스트업, 시행 여부 체크박스.\n- **기본 보안**: 환자정보 암호화 저장, HTTPS 통신.\n- **개발 환경 설정**: 개발 환경 구축, CI/CD 파이프라인 설정.\n- **예상 완료 기간**: 2주\n\n### 2단계: 기능 개선\n- **고급 기능**: 알림 기능 (대시보드 표시, Push 알림), 대시보드 (항목별 진행 현황 요약), 사용자 정의 항목.\n- **성능 최적화**: 시스템 성능 개선.\n- **보안 강화**: 보안 기능 강화 및 컴플라이언스 준수.\n- **모니터링 구현**: 종합적인 모니터링 시스템 설정.\n- **예상 완료 기간**: 3주\n\n## 6. 위험 평가 & 완화 전략\n### 기술적 위험 분석\n- **기술 위험**: Next.js, Supabase 등 기술 스택에 대한 이해 부족.\n- **성능 위험**: 데이터 증가에 따른 성능 저하 가능성.\n- **보안 위험**: 환자 정보 유출 가능성.\n- **통합 위험**: Web Push API 연동 문제.\n- **완화 전략**:\n    - 기술 스택 학습 및 숙련.\n    - 성능 테스트 및 최적화.\n    - 보안 취약점 점검 및 보안 강화.\n    - Web Push API 연동 테스트 및 문제 해결.\n\n### 프로젝트 납기 위험\n- **일정 위험**: 개발 일정 지연 가능성.\n- **자원 위험**: 개발 인력 부족 가능성.\n- **품질 위험**: 코드 품질 저하 가능성.\n- **배포 위험**: 배포 환경 문제 발생 가능성.\n- **비상 계획**:\n    - 개발 일정 단축 및 우선순위 조정.\n    - 추가 개발 인력 확보.\n    - 코드 리뷰 및 테스트 강화.\n    - 배포 환경 사전 점검 및 문제 해결.\n",
      "writedAt": "2025-08-16T08:11:56.248Z"
    },
    {
      "type": "guideline",
      "content": "\n  # Senior Developer Guidelines\n  \n  ## Must\n  \n  - always use client component for all components. (use `use client` directive)\n  - always use promise for page.tsx params props.\n  - use valid picsum.photos stock image for placeholder image\n  \n  ## Library\n  \n  use following libraries for specific functionalities:\n  \n  1. `date-fns`: For efficient date and time handling.\n  2. `ts-pattern`: For clean and type-safe branching logic.\n  3. `@tanstack/react-query`: For server state management.\n  4. `zustand`: For lightweight global state management.\n  5. `react-use`: For commonly needed React hooks.\n  6. `es-toolkit`: For robust utility functions.\n  7. `lucide-react`: For customizable icons.\n  8. `zod`: For schema validation and data integrity.\n  9. `shadcn-ui`: For pre-built accessible UI components.\n  10. `tailwindcss`: For utility-first CSS styling.\n  11. `supabase`: For a backend-as-a-service solution.\n  12. `react-hook-form`: For form validation and state management.\n  \n  ## Directory Structure\n  \n  - src\n  - src/app: Next.js App Routers\n  - src/components/ui: shadcn-ui components\n  - src/constants: Common constants\n  - src/hooks: Common hooks\n  - src/lib: utility functions\n  - src/remote: http client\n  - src/features/[featureName]/components/*: Components for specific feature\n  - src/features/[featureName]/constants/*\n  - src/features/[featureName]/hooks/*\n  - src/features/[featureName]/lib/*\n  - src/features/[featureName]/api.ts: api fetch functions\n  \n  ## Solution Process:\n  \n  1. Rephrase Input: Transform to clear, professional prompt.\n  2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n  3. Develop Solution:\n     - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n     - List steps numerically.\n     - \"To resolve these steps, I need the following solutions:\"\n     - List solutions with bullet points.\n  4. Validate Solution: Review, refine, test against edge cases.\n  5. Evaluate Progress:\n     - If incomplete: Pause, inform user, await input.\n     - If satisfactory: Proceed to final output.\n  6. Prepare Final Output:\n     - ASCII title\n     - Problem summary and approach\n     - Step-by-step solution with relevant code snippets\n     - Format code changes:\n      ```language:path/to/file\n       // ... existing code ...\n       function exampleFunction() {\n           // Modified or new code here\n       }\n       // ... existing code ...\n       ```\n     - Use appropriate formatting\n     - Describe modifications\n     - Conclude with potential improvements\n  \n  ## Key Mindsets:\n  \n  1. Simplicity\n  2. Readability\n  3. Maintainability\n  4. Testability\n  5. Reusability\n  6. Functional Paradigm\n  7. Pragmatism\n  \n  ## Code Guidelines:\n  \n  1. Early Returns\n  2. Conditional Classes over ternary\n  3. Descriptive Names\n  4. Constants > Functions\n  5. DRY\n  6. Functional & Immutable\n  7. Minimal Changes\n  8. Pure Functions\n  9. Composition over inheritance\n  \n  ## Functional Programming:\n  \n  - Avoid Mutation\n  - Use Map, Filter, Reduce\n  - Currying and Partial Application\n  - Immutability\n  \n  ## Code-Style Guidelines\n  \n  - Use TypeScript for type safety.\n  - Follow the coding standards defined in the ESLint configuration.\n  - Ensure all components are responsive and accessible.\n  - Use Tailwind CSS for styling, adhering to the defined color palette.\n  - When generating code, prioritize TypeScript and React best practices.\n  - Ensure that any new components are reusable and follow the existing design patterns.\n  - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n  - Always validate user inputs and handle errors gracefully.\n  - Use the existing components and pages as a reference for the new components and pages.\n  \n  ## Performance:\n  \n  - Avoid Premature Optimization\n  - Profile Before Optimizing\n  - Optimize Judiciously\n  - Document Optimizations\n  \n  ## Comments & Documentation:\n  \n  - Comment function purpose\n  - Use JSDoc for JS\n  - Document \"why\" not \"what\"\n  \n  ## Function Ordering:\n  \n  - Higher-order functionality first\n  - Group related functions\n  \n  ## Handling Bugs:\n  \n  - Use TODO: and FIXME: comments\n  \n  ## Error Handling:\n  \n  - Use appropriate techniques\n  - Prefer returning errors over exceptions\n  \n  ## Testing:\n  \n  - Unit tests for core functionality\n  - Consider integration and end-to-end tests\n  \n  ## Next.js\n  \n  - you must use promise for page.tsx params props.\n  \n  ## Shadcn-ui\n  \n  - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n  - example\n    ```\n    $ npx shadcn@latest add card\n    $ npx shadcn@latest add textarea\n    $ npx shadcn@latest add dialog\n    ```\n  \n  ## Supabase\n  \n  - if you need to add new table, please create migration. I'll paste it into supabase.\n  - do not run supabase locally\n  - store migration query for `.sql` file. in /supabase/migrations/\n  \n  ## Package Manager\n  \n  - use npm as package manager.\n  \n  ## Korean Text\n  \n  - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n  \n  You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n  Apply these principles judiciously, considering project and team needs.\n    ",
      "writedAt": "2025-08-16T08:11:56.248Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-16T08:11:56.248Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-16T08:11:56.248Z"
    }
  ]
}